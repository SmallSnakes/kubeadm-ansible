image:
  repository: {{ kube_image_repository }}/redis
  tag: {{ kube_image_tag }}
  pullPolicy: IfNotPresent
replicas: 3

labels: {}

serviceAccount:
  create: true

rbac:
  create: true
sysctlImage:
  enabled: false
  command: []
  registry: docker.io
  repository: bitnami/minideb
  tag: latest
  pullPolicy: IfNotPresent
  mountHostSys: false

redis:
  port: "{{ redis_server_port }}"
  masterGroupName: "{{ redis_master_group_name }}"
  config:
    min-slaves-to-write: 1
    min-slaves-max-lag: 5
    maxmemory: "0"
    maxmemory-policy: "volatile-lru"
    save: "900 1"
    repl-diskless-sync: "yes"
    rdbcompression: "yes"
    rdbchecksum: "yes"

  resources:
    requests:
      memory: 200Mi
      cpu: 100m
    limits:
      memory: 700Mi

sentinel:
  port: "{{ redis_sentinel_port }}"
  quorum: 2
  config:
    down-after-milliseconds: 10000
    failover-timeout: 180000
    parallel-syncs: 5

  resources:
    requests:
      memory: 200Mi
      cpu: 100m
    limits:
      memory: 200Mi

securityContext:
  runAsUser: 1000
  fsGroup: 1000
  runAsNonRoot: true

nodeSelector:
  {{ control_node_role_name }}: {{ node_role_value }}
hardAntiAffinity: true
additionalAffinities: {}

affinity: |

exporter:
  enabled: false
  image: oliver006/redis_exporter
  tag: v0.31.0
  pullPolicy: IfNotPresent
  port: 9121
  scrapePath: /metrics
  resources: {}
  extraArgs: {}

podDisruptionBudget: {}
redisPassword: "{{ redis_master_password }}"
# existingSecret:
authKey: auth

persistentVolume:
  enabled: true
  storageClass: "{{ rbd_storage_class_name }}"
  accessModes:
    - ReadWriteOnce
  size: "{{ redis_storage_size }}"
  annotations: {}
init:
  resources: {}
hostPath:
  chown: true
